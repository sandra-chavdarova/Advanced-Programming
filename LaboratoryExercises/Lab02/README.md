# Date and Time
## 1. LocalDate
Довршете ги методите

Output:
```
2015-06-18
2015-06-18
2015
2016-01-01
2016-04-18
2015-06-08
2016-08-21
true
P1M20D
```

## 2. LocalDateTime
Output:
```
2015-06-20T23:07:30
2015-06-20T23:07:30
2015-07-01T23:00
2016-04-18T18:07:30.500
2015_06_18_23_07_30
2015-06-1823:07:30.500
2015-06-18T23:07:30.500 2015-06-18T23:07:30.500
```

## 3. LocalTime
Output:
```
23:07
23:07:03.100
23:07:03.100
21:07:30.500
23:37:30.500
20:07:30.500
19:37:10.300
true
23:07
```

# Generics
## 4. Resizable Array
Да се напише класа **ResizableArray** која ќе претставува поле (низа) со променлива должина. Класата може да чува елементи од било кој тип (треба да биде генеричка со еден параметар T) и треба да ги има дефинирано следните методи:
- ResizableArray() - креира ново празно поле
- addElement(T element) - додава нов елемент во полето (доколку нема доволно место го зголемува капацитетот на полето).
- removeElement(T element):boolean - aко постои таков елемент истиот го брише и враќа true, во спротивно враќа false, доколку има повеќе инстанци од дадениот елемент се брише само една од нив (ако има многу празно место во полето го намалува неговиот капацитет)
- contains(T element):boolean - враќа true доколку во полето постои дадениот елемент
- toArray():Object[] - ги враќа сите елементи во полето како обична низа
- isEmpty() - враќа true доколку во полето нема ниеден елемент
- count():int - го браќа бројот на елементи во полето
- elementAt(int idx):T - го враќа елементот на соодветната позиција, доколку нема таков фрла исклучок ArrayIndexOutOfBoundsException (елементите во полето се наоѓаат на позиции [0, count()])

Забелешка: за чување на елементите мора да се користи обична низа Т[] elements, не смее да се користи ArrayList<T> и истата мора да биде декларирана како private.

Дополнително, класата ResizableArray треба да има еден статички метод:
- <T> void copyAll(ResizableArray<? super T> dest, ResizableArray<? extends T> src)
Овој метод треба да изврши копирање на сите елементи од src во dest (src останува непроменета, dest ги содржи сите елементи кои ги имал од порано и дополнително сите елементи кои ги има во src).

Следно треба да се напише класа **IntegerArray** која наследува од класата ResizableArray IntegerArray extends ResizableArray<Integer> и служи за чување на цели броеви. Оваа класа ги нуди следниве методи:
- sum():double - ја враќа сумата на сите елементи во полето
- mean():double - го дава просекот на сите елементи во полето
- countNonZero():int - го дава бројот на елементи во полето кои имаат вредност различна од нула
- distinct():IntegerArray - враќа нов објект кој во себе ги содржи истите елементи кои ги содржи this, но нема дупликат елементи
- increment(int offset):IntegerArray - враќа нов објект кој во себе ги содржи сите елемeнти кои ги содржи this, но на нив додавајќи offset

Input:
```
1
	 qwe asd zxc ert dfg
```

Output:
```
0
1
5
true
true
true
false
4
4
4
false
true
false
true
8
4
false
true
false
true
false
false
false
false
false
12
4
false
true
false
true
```

## 5. Timestamp
Треба да се развие класа **Timestamp** која претставува пар на објекти од кои едниот е секогаш од тип LocalDateTime, а другиот објект е од генеричкиот тип T. Класата Timestamp ги нуди следниве функционалности:
- Timestamp(LocalDateTime time, T element) - конструктор
- getTime():LocalDateTime
- getElement():T
- compareTo(Timestamp<?> t):int - споредувањето се прави само врз основа на времињата
- equals(Object o):boolean - враќа true ако се исти времињата
- toString() :String - враќа стринг репрезентација со времето (toString) и елементот во формат time element

Забелешка: двете променливи time и element мора да бидат обележани како final.

Класата Timestamp сега треба да се искористи за да се развие класа **Scheduler**. Оваа класа чува повеќе објекти од класата Timestamp и исто така има еден генерички параметар T кој всушност се однесува на типот на објект кој се наоѓа во Timestamp. Класата Scheduler треба да ги имплементира следниве методи:
- Scheduler() - креира нов празен распоредувач
- add(Timestamp<T> t) - додава нов објект во распоредувачот
- remove(Timestamp<T> t):boolean - го брише соодветниот елемент од распоредувачот доколку постои и враќа true, во спротивно враќа false
- next():Timestamp<T> - го враќа следниот Timestamp објект, односно тој објект чие што време е најблиску до тековното (сега) и сѐ уште НЕ е поминато
- last():Timestamp<T> - го враќа објектот кој има време најблиску до тековното (сега) и веќе E поминат
- getAll(LocalDateTime begin, LocalDateTime end):List<Timestamp<T>> - враќа листа на настани чии времиња се наоѓаат помеѓу begin и end (не вклучувајќи ги begin и end).

Input:
```
0 test
```

Output:
```
2016-10-25T10:15 test
2016-10-25T10:15
test
```

## 6. Queuе
Треба да се развие класа **Queuе** која претставува податочна структура ред, a во позадина e имплементирана како поврзана листа. Прво треба да се напише класа за еден елемент во листата (еден јазел) Node. Kласаta **Node** треба да има еден генерички параметар Т кој се однесува на елементот во јазелот и една референца кон следниот јазел во листата. Поформално класата Node треба да ги нуди следниве методи:
- Node(T element, Node<T> next) - конструктор кој ги иницијализира двете променливи
- getElement():T
- getNext():Node<T>
- setNext(Node<T> next)

Користејќи ја класата Node ја пишуваме класата Queue со следниве методи:
- Queue() – креира нов празен ред
- isEmpty():boolean - враќа true, ако редот е празен (не содржи ниеден елемент)
- enqueue(T element) - го додава елементот на крајот на редот
- dequeue():T - го отстранува елементот на почеток од редот и истиот го враќа, доколку редот е празен фрла исклучок EmptyQueueException
- peek():T - го враќа елементот на почетокот од редот (не ја менува листата), доколку редот е празен фрла исклучок EmptyQueueException
- inspect():T - го враќа елементот на крајот на редот (не ја менува листата), доколку редот е празен фрла исклучок EmptyQueueException
- count():int - го враќа бројот на елементи во редот

**Забелешка: Класата Queue има еден генерички параметар кој се однесува на типот не елементи кои се чуваат во редот.**
**Важно: Не смее да се користат готови податочни структури како ArrayList или LinkedList, за да се имплементира класата Queue.**

Input:
```
1 12453 451236 45789 456123 77889 121233 47864556 45346789 1453456 14534523 4578646 745389 445354  689661 34531254 5373541 6734584 545345 1 8453454 84534594 6534531  9843454 54351 453458 445389 4 654531 6545331 681231 8789  678351 651 9 84 894 5 16 57864 9453788 4 54531231 64 9434128 4534534 1  845344 873434  5832321 56845 47834589 46 518941 56 48123459 sample test
```

Output:
```
12453
451236
45789
456123
77889
121233
47864556
45346789
1453456
14534523
4578646
745389
445354
689661
34531254
5373541
6734584
545345
1
8453454
84534594
6534531
9843454
54351
453458
445389
4
654531
6545331
681231
8789
678351
651
9
84
894
5
16
57864
9453788
4
54531231
64
9434128
4534534
1
845344
873434
5832321
56845
47834589
46
518941
56
48123459
Queue inspect? - sample
Queue peek? - sample
Queue inspect? - test
Queue peek? - sample
```

## 7. Complex Number
Треба да се развие генеричка класа за работа со комплексни броеви **ComplexNumber** со два генерички параметри T и U кои мора да бидат од некоја класа која наследува од класата Number (T extends Number). ComplexNumber има две променливи од кои едната се однесува на реалниот дел, а другата на имагинарниот дел и треба да ги имплементира следните методи:
- ComplexNumber(T real, U imaginary) - конструктор кој ги иницијализира сите променливи
- getReal():T
- getImaginary():U
- modul():double - го пресметува модулот на комплексниот број
- compareTo(ComplexNumber<?, ?> o) - прави споредување врз основа на модулите на двата комплексни броја
- toString():String - го печати бројот во следниот формат 2.30+3.00i

Input:
```
3
1.12 2.45
212.45 3.12
0 -1
-1.45 0
45 -56.45
-5.45 -6.45
0 0.12
asd
```

Output:
```
[1.12+2.45i, 212.45+3.12i, 0.00-1.00i, -1.45+0.00i, 45.00-56.45i, -5.45-6.45i, 0.00+0.12i]
[0.00+0.12i, 0.00-1.00i, -1.45+0.00i, 1.12+2.45i, -5.45-6.45i, 45.00-56.45i, 212.45+3.12i]
```
